11.	Помните структуру sterling? Мы встречались с ней в упражнении 10 гла-
вы 2 «Основы программирования на C++», в упражнении 11 главы 5 и
 
в других местах. Преобразуйте ее в класс, имеющий переменные для фун-
тов (типа long), шиллингов (типа int) и пенсов (типа int). Создайте в
классе следующие функции:
¦	конструктор без аргументов;
¦	конструктор с одним аргументом типа double  (для преобразования от
десятичных фунтов);
¦	конструктор с тремя аргументами: фунтами, шиллингами и пенсами;
¦	метод getSterling() для получения от пользователя значений количества
фунтов, шиллингов и пенсов в формате ?9.19.11;
¦	метод putSterling() для вывода значений количества фунтов, шиллин-
гов и пенсов в формате ?9.19.11;
¦	метод для сложения (sterling + sterling), используя перегруженную операцию +;
¦	метод вычитания (sterling - sterling), используя перегруженную операцию -;
¦	метод умножения (sterling * double), используя перегруженную операцию *;
¦	метод деления (sterling / sterling), используя перегруженную операцию /;
¦	метод деления (sterling / double), используя перегруженную операцию /;
¦	операцию double  (для преобразования к типу double)

Выполнять вычисления вы можете, например, складывая отдельно дан-
ные объекта: сложить сначала пенсы, затем шиллинги и т. д. Однако легче
использовать операцию преобразования для преобразования объекта клас-
са sterling к типу double, выполнить вычисления с типами double, а затем
преобразовать обратно к типу sterling. Таким образом, операция + выгля-
дит похожей на эту:
 sterling sterling::operator+(sterling s2)
 {
	 return sterling(double(sterling(pounds, shillings, pense)) + double(s2));
 }
Так мы создадим две временных переменных типа double, одна происхо-
дит от объекта, который вызывает функцию, а другая от аргумента s2.
Эти переменные затем складываются, результат преобразовывается к ти-
пу sterling и возвращается.
Заметим, что мы использовали другой подход для класса sterling, нежели
для класса bMoney. В классе sterling мы используем операции преобразова-
ния, таким образом отказавшись от возможности поиска неправильных
операций, но получив простоту при записи перегружаемых математиче-
ских операций.
